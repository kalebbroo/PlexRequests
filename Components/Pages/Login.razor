@page "/"
@page "/login"
@attribute [AllowAnonymous]
@rendermode InteractiveServer
@using PlexRequestsHosted.Services.Auth
@implements IDisposable
@using System.Linq
@using PlexRequestsHosted.Utils
@inject PlexRequestsHosted.Services.Abstractions.IPlexAuthService PlexAuthService
@inject AuthenticationStateProvider AuthStateProvider
@inject PlexRequestsHosted.Services.Abstractions.IToastService ToastService
@inject NavigationManager Navigation
@inject PlexRequestsHosted.Services.Abstractions.IMediaMetadataProvider MetadataProvider
@using Microsoft.AspNetCore.WebUtilities

<PageTitle>Sign In - Plex Request</PageTitle>

<div class="login-container">
    <div class="background-wrapper">
        <div class="background-image bgA @( _showA ? "visible" : string.Empty)" style="background-image: url('@(_bgA ?? _currentBackdrop ?? "/favicon.png")')"></div>
        <div class="background-image bgB @( !_showA ? "visible" : string.Empty)" style="background-image: url('@(_bgB ?? "/favicon.png")')"></div>
        <div class="gradient-overlay"></div>
    </div>
    <div class="login-content">
        <MudContainer MaxWidth="MaxWidth.Small">
            <MudPaper Class="login-card animate-slide-up" Elevation="24">
                <div class="login-header">
                    <MudText Typo="Typo.h3" Class="brand-title">PLEX REQUEST</MudText>
                    <MudText Typo="Typo.h5" Class="login-title">Sign In</MudText>
                </div>

                @if (_isProcessing)
                {
                    <div class="auth-processing">
                        <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
                        <MudText Typo="Typo.body1" Class="mt-4">@_processingMessage</MudText>
                    </div>
                }
                else
                {
                    <div class="login-options">
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Large" FullWidth="true" StartIcon="@Icons.Material.Filled.Login" @onclick="SignInWithPlex" Class="plex-button hover-scale">
                            <MudText Typo="Typo.button">Sign in with Plex</MudText>
                        </MudButton>


                        <MudExpansionPanels Elevation="0" Class="manual-entry">
                            <MudExpansionPanel Text="Advanced: Enter Plex Token Manually">
                                <EditForm Model="@_tokenForm" OnValidSubmit="SignInWithToken">
                                    <MudTextField @bind-Value="_manualToken" Label="Plex Token" Variant="Variant.Outlined" InputType="@(_showToken ? InputType.Text : InputType.Password)" Adornment="Adornment.End" AdornmentIcon="@(_showToken ? Icons.Material.Filled.Visibility : Icons.Material.Filled.VisibilityOff)" OnAdornmentClick="ToggleTokenVisibility" HelperText="Your Plex authentication token" FullWidth="true" autocomplete="new-password" />
                                    <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Outlined" Color="Color.Primary" FullWidth="true" Disabled="@string.IsNullOrWhiteSpace(_manualToken)" Class="mt-3">Sign in with Token</MudButton>
                                </EditForm>
                                <MudAlert Severity="Severity.Info" Class="mt-3" Dense="true">
                                    <MudLink Href="https://support.plex.tv/articles/204059436-finding-an-authentication-token-x-plex-token/" Target="_blank" Color="Color.Info">How to find your Plex token</MudLink>
                                </MudAlert>
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    </div>

                    <div class="login-info">
                        <MudText Typo="Typo.body2" Class="text-center" Color="Color.Tertiary">Sign in with your Plex account to request movies and TV shows</MudText>
                        <MudDivider Class="my-3" />
                        <div class="benefits-list">
                            <div class="benefit-item"><MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success" Size="Size.Small" /><MudText Typo="Typo.caption">Request unlimited movies and shows</MudText></div>
                            <div class="benefit-item"><MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success" Size="Size.Small" /><MudText Typo="Typo.caption">Track request status in real-time</MudText></div>
                            <div class="benefit-item"><MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success" Size="Size.Small" /><MudText Typo="Typo.caption">Get notified when content is available</MudText></div>
                        </div>
                    </div>
                }
            </MudPaper>

            <div class="login-footer">
                <MudLink Href="/about" Color="Color.Inherit">About</MudLink>
                <MudLink Href="/privacy" Color="Color.Inherit">Privacy</MudLink>
                <MudLink Href="/terms" Color="Color.Inherit">Terms</MudLink>
                <span class="tmdb-attr">This product uses the TMDB API but is not endorsed or certified by TMDB.</span>
            </div>
        </MudContainer>
    </div>
</div>

@code {
    private bool _isProcessing;
    private string _processingMessage = "Connecting to Plex...";
    private string _manualToken = string.Empty;
    private bool _showToken;
    private bool _isDevelopment;
    private string _returnUrl = "/";
    private List<string> _backdrops = new();
    private string? _currentBackdrop;
    private int _backdropIndex = 0;
    private System.Timers.Timer? _bgTimer;
    // Dual-layer background for smooth crossfade
    private string? _bgA;
    private string? _bgB;
    private bool _showA = true;
    private bool _redirecting = false;
    private readonly object _tokenForm = new();
    private int _redirectAttempts = 0;
    private const int MAX_REDIRECT_ATTEMPTS = 3;
    private DateTime _lastRedirectAttempt = DateTime.MinValue;

    protected override async Task OnInitializedAsync()
    {
        Logs.Info("Login page initialized");
        
        try
        {
            var authState = await ((CustomAuthStateProvider)AuthStateProvider).GetAuthenticationStateAsync();
            if (authState.User.Identity?.IsAuthenticated == true)
            {
                // Circuit breaker: prevent endless redirect loops
                if (_redirectAttempts >= MAX_REDIRECT_ATTEMPTS)
                {
                    Logs.Error($"Too many redirect attempts ({_redirectAttempts}). Stopping to prevent infinite loop.");
                    await ToastService.ShowErrorAsync("Authentication error: Too many redirects. Please refresh the page.");
                    return;
                }

                // Rate limit redirects
                if (DateTime.UtcNow - _lastRedirectAttempt < TimeSpan.FromSeconds(2))
                {
                    Logs.Warning("Redirect rate limited. Waiting before next attempt.");
                    return;
                }

                if (!_redirecting)
                {
                    _redirecting = true;
                    _redirectAttempts++;
                    _lastRedirectAttempt = DateTime.UtcNow;
                    Logs.Info($"User authenticated as {authState.User.Identity.Name}; redirecting to /browse (attempt {_redirectAttempts})");
                    
                    // Use a more aggressive redirect to break out of any loops
                    await Task.Delay(500); // Give time for state to stabilize
                    Navigation.NavigateTo("/browse", forceLoad: true);
                }
                return;
            }
            else
            {
                Logs.Info("User not authenticated, showing login page");
                _redirectAttempts = 0; // Reset counter when not authenticated
            }

            var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
            // Capture returnUrl from query string if present
            var query = QueryHelpers.ParseQuery(uri.Query);
            if (query.TryGetValue("returnUrl", out var r))
            {
                var candidate = r.ToString();
                if (!string.IsNullOrWhiteSpace(candidate))
                    _returnUrl = candidate;
            }

            // Check for authentication errors from callback
            if (query.TryGetValue("error", out var error))
            {
                var errorMsg = error.ToString() switch
                {
                    "no_pin" => "Authentication session expired. Please try again.",
                    "auth_failed" => "Plex authentication failed. Please try again.",
                    "auth_completion_failed" => "Failed to complete authentication. Please try again.",
                    "callback_error" => "An error occurred during authentication. Please try again.",
                    _ => "Authentication failed. Please try again."
                };
                await ToastService.ShowErrorAsync(errorMsg);
                Logs.Warning($"Authentication error from callback: {error}");
            }

            #if DEBUG
            _isDevelopment = true;
            #endif

            // Load some great-looking backdrops from TMDB for the background
            await LoadBackgroundImages();
        }
        catch (Exception ex)
        {
            Logs.Error($"Login page initialization failed: {ex}");
            await ToastService.ShowErrorAsync("Failed to initialize login page");
        }
    }

    private async Task SignInWithPlex()
    {
        Logs.Info("SignInWithPlex clicked");
        _isProcessing = true;
        _processingMessage = "Connecting to Plex...";
        StateHasChanged();
        
        try
        {
            var flow = await PlexAuthService.BeginAuthenticationAsync();
            if (!flow.Success)
            {
                await ToastService.ShowErrorAsync(flow.ErrorMessage ?? "Failed to start authentication");
                Logs.Error($"BeginAuthenticationAsync failed: {flow.ErrorMessage}");
                _isProcessing = false;
                return;
            }

            Logs.Info($"Plex auth flow ready. pinId={flow.PinId}, redirecting to Plex OAuth");
            _processingMessage = "Redirecting to Plex sign-in...";
            StateHasChanged();
            
            // Small delay to show the message
            await Task.Delay(500);
            
            // Redirect to Plex OAuth (this will navigate away from our page)
            await PlexAuthService.OpenAuthenticationWindowAsync(flow.AuthenticationUrl);
        }
        catch (Exception ex)
        {
            await ToastService.ShowErrorAsync("An error occurred during authentication");
            Logs.Error($"SignInWithPlex exception: {ex}");
            _isProcessing = false;
        }
    }

    private async Task SignInWithToken()
    {
        if (string.IsNullOrWhiteSpace(_manualToken)) return;
        _isProcessing = true; _processingMessage = "Validating token..."; StateHasChanged();
        try
        {
            var user = await PlexAuthService.GetPlexUserAsync(_manualToken);
            if (user == null)
            { await ToastService.ShowErrorAsync("Invalid Plex token"); _isProcessing = false; return; }
            await CompleteAuthentication(_manualToken, user.Username);
        }
        catch
        {
            await ToastService.ShowErrorAsync("Failed to validate token"); _isProcessing = false;
        }
    }

    private async Task CompleteAuthentication(string plexToken, string plexUsername)
    {
        _processingMessage = "Completing sign-in..."; StateHasChanged();
        var result = await ((CustomAuthStateProvider)AuthStateProvider).AuthenticateWithPlexAsync(plexToken, plexUsername);
        if (result.Success)
        {
            await ToastService.ShowSuccessAsync($"Welcome back, {result.User?.DisplayName ?? plexUsername}!");
            // Choose a safe destination; avoid redirecting back to login or root
            var target = _returnUrl;
            if (string.IsNullOrWhiteSpace(target) || target == "/" || target.StartsWith("/login", StringComparison.OrdinalIgnoreCase))
                target = "/browse";
            Logs.Info($"Post-auth redirect to {target}");
            // Use client-side navigation to avoid SSR re-prerender causing auth flicker
            Navigation.NavigateTo(target, false);
        }
        else
        {
            await ToastService.ShowErrorAsync(result.ErrorMessage ?? "Authentication failed");
            _isProcessing = false;
        }
    }

    private async Task LoadBackgroundImages()
    {
        try
        {
            if (_redirecting) return;
            Logs.Info("Fetching TMDB backdrops for login background");
            var cards = await MetadataProvider.GetRecentlyAddedAsync(20);
            _backdrops = cards
                .Select(c => c.BackdropUrl ?? c.PosterUrl)
                .Where(u => !string.IsNullOrWhiteSpace(u))
                .Distinct()
                .Take(12)
                .ToList()!;

            if (_backdrops.Count > 0)
            {
                _currentBackdrop = _backdrops[0];
                _bgA = _backdrops[0];
                _bgB = _backdrops.Count > 1 ? _backdrops[1] : _backdrops[0];
                _backdropIndex = 1; // we already used index 0 (and maybe 1)
                StartBackgroundRotation();
                Logs.Info($"Loaded {_backdrops.Count} backdrop(s) for login background");
            }
            else
            {
                Logs.Warning("No TMDB backdrops available; using fallback image");
            }
        }
        catch (Exception ex)
        {
            Logs.Warning($"TMDB backdrop load failed (non-fatal): {ex.Message}");
        }
    }


    private void ToggleTokenVisibility() => _showToken = !_showToken;


    private void StartBackgroundRotation()
    {
        if (_backdrops.Count <= 1) return;
        _bgTimer = new System.Timers.Timer(9000);
        _bgTimer.Elapsed += (_, __) =>
        {
            try
            {
                _backdropIndex = (_backdropIndex + 1) % _backdrops.Count;
                var next = _backdrops[_backdropIndex];
                if (_showA)
                {
                    _bgB = next;
                    _showA = false;
                }
                else
                {
                    _bgA = next;
                    _showA = true;
                }
                _currentBackdrop = next;
                InvokeAsync(StateHasChanged);
            }
            catch { /* ignore */ }
        };
        _bgTimer.AutoReset = true;
    }

    public void Dispose()
    {
        _bgTimer?.Stop();
        _bgTimer?.Dispose();
    }
}

<style>
    /* Full-bleed cinematic background */
    .login-container { position: relative; min-height: 100vh; display: flex; align-items: center; justify-content: center; background: #0d0d0d; }
    .background-wrapper { position: absolute; inset: 0; overflow: hidden; }
    .background-image { position: absolute; inset: 0; background-size: cover; background-position: center; filter: brightness(0.35) saturate(1.1); transform: scale(1.05); opacity: 0; transition: opacity 1.6s ease, filter .6s ease; }
    .background-image.visible { opacity: 1; }
    .bgA { animation: kenburns 22s ease-in-out infinite alternate; }
    .bgB { animation: kenburns 22s ease-in-out infinite alternate-reverse; }
    .gradient-overlay { position: absolute; inset: 0; background: radial-gradient(ellipse at center, rgba(0,0,0,.35) 0%, rgba(0,0,0,.65) 45%, rgba(0,0,0,.9) 100%), linear-gradient(to bottom, rgba(0,0,0,.7) 0%, rgba(20,20,20,.95) 100%); }
    @@keyframes kenburns { from { transform: scale(1.05) translateY(0); } to { transform: scale(1.12) translateY(-10px); } }

    /* Card */
    .login-content { position: relative; z-index: 1; width: 100%; padding: 2rem; }
    .login-card { background: rgba(0,0,0,.82) !important; backdrop-filter: blur(12px); padding: 3rem 2rem; border-radius: 12px; border: 1px solid rgba(255,255,255,.05); box-shadow: var(--shadow-xl, 0 16px 32px rgba(0,0,0,.6)); }
    .login-header { text-align: center; margin-bottom: 2rem; }
    .brand-title { color: #E5A00D; font-weight: 900; letter-spacing: .15rem; margin-bottom: .5rem; }
    .login-title { color: #fff; font-weight: 500; opacity: .9; }
    .auth-processing { text-align: center; padding: 3rem 0; }

    /* Buttons */
    .plex-button { background: linear-gradient(45deg, #E5A00D 0%, #F9BE03 100%) !important; color: #000 !important; font-weight: 700; padding: 14px 24px !important; border-radius: 10px; box-shadow: 0 10px 24px rgba(229,160,13,.25); }
    .plex-button:hover { filter: brightness(1.02); box-shadow: 0 12px 28px rgba(229,160,13,.35); }
    .manual-entry { background: transparent !important; }

    /* Info list */
    .login-info { margin-top: 2rem; padding-top: 1rem; }
    .benefits-list { display: flex; flex-direction: column; gap: .75rem; margin-top: 1rem; }
    .benefit-item { display: flex; align-items: center; gap: .75rem; opacity: .9; }

    /* Footer */
    .login-footer { display: flex; justify-content: center; gap: 2rem; margin-top: 2rem; opacity: .7; flex-wrap: wrap; }
    .tmdb-attr { font-size: .75rem; color: #9aa0a6; opacity: .8; }

    /* Hide app chrome on login for immersive look */
    .app-header, .app-footer { display: none; }

    @@media (max-width: 600px) { .login-card { padding: 2rem 1.5rem; } .brand-title { font-size: 1.75rem; } }
</style>
